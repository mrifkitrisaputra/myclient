{
    "sourceFile": "src/main/java/com/client/render/GameCanvas.java",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1764831883073,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764832496774,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,98 +1,63 @@\n-package com.client.render;\r\n+package com.myclient.render;\r\n \r\n-import com.client.core.Arena;\r\n-import com.client.core.CollisionHandler;\r\n-import com.client.core.GameTimer;\r\n-import com.client.core.InputHandler;\r\n-import com.client.entities.Player;\r\n-import com.client.managers.BombManager;\r\n-import com.client.managers.ExplosionManager;\r\n-import com.client.managers.ItemManager; \r\n-import com.client.managers.PlayerController;\r\n-import com.client.map.MapGenerator;\r\n-\r\n+import com.myclient.ClientGameState;\r\n import javafx.animation.AnimationTimer;\r\n import javafx.scene.canvas.Canvas;\r\n+import javafx.scene.input.KeyCode;\r\n \r\n public class GameCanvas extends Canvas {\r\n-    private final GameUpdater updater;\r\n+    \r\n+    // Referensi ke \"Otak Semu\" Client\r\n+    private final ClientGameState gameState;\r\n     private final GameRenderer renderer;\r\n+    private final CameraScaler scaler;\r\n \r\n-    private double renderScale = 1.8;\r\n-    private static final double MIN_SCALE = 0.5;\r\n-    private static final double MAX_SCALE = 4.0;\r\n-    private static final double SCALE_STEP = 0.1;\r\n-\r\n-    private final int tile = 32;\r\n-    private final int[][] map;\r\n-    private final Arena arena;\r\n-\r\n-    // Loop game\r\n+    // Loop Render\r\n     private final AnimationTimer loop = new AnimationTimer() {\r\n         long last = System.nanoTime();\r\n \r\n         @Override\r\n         public void handle(long now) {\r\n             double dt = (now - last) / 1e9;\r\n             last = now;\r\n-            updater.update(dt);\r\n+            \r\n+            // 1. Update animasi visual (bukan logika game)\r\n+            if (gameState != null) {\r\n+                gameState.updateVisuals(dt);\r\n+            }\r\n+\r\n+            // 2. Render\r\n             renderer.render();\r\n         }\r\n     };\r\n-    \r\n-    // Method untuk Stop Loop saat keluar room\r\n+\r\n+    public GameCanvas(ClientGameState gameState) {\r\n+        this.gameState = gameState;\r\n+        this.scaler = new CameraScaler(this);\r\n+        \r\n+        // Renderer mengambil data dari gameState\r\n+        this.renderer = new GameRenderer(this, gameState, scaler);\r\n+\r\n+        // Bind ukuran canvas ke scene nanti\r\n+        widthProperty().addListener(evt -> renderer.render());\r\n+        heightProperty().addListener(evt -> renderer.render());\r\n+    }\r\n+\r\n+    public void start() {\r\n+        loop.start();\r\n+    }\r\n+\r\n     public void stop() {\r\n         loop.stop();\r\n     }\r\n \r\n-    // Method untuk Resume Game dari Pause Menu\r\n-    public void resume() {\r\n-        updater.resumeGame();\r\n+    // Helper untuk Input Zoom (Optional)\r\n+    public void handleInput(KeyCode code) {\r\n+        switch (code) {\r\n+            case EQUALS, ADD -> scaler.addScale(0.1);\r\n+            case MINUS, SUBTRACT -> scaler.addScale(-0.1);\r\n+        }\r\n     }\r\n \r\n-    public GameCanvas(Player player, InputHandler input) {\r\n-        int[] spawnPos = new int[2];\r\n-        this.map = MapGenerator.generate(13, 13, spawnPos);\r\n-        this.arena = new Arena(map);\r\n-\r\n-        ItemManager itemManager = new ItemManager(tile);\r\n-        BombManager bombManager = new BombManager(this);\r\n-        ExplosionManager explosionManager = new ExplosionManager(map, itemManager); \r\n-        CollisionHandler collider = new CollisionHandler(map, tile);\r\n-\r\n-        PlayerController playerController = new PlayerController(\r\n-                player, input, collider, bombManager, explosionManager, spawnPos\r\n-        );\r\n-\r\n-        CameraScaler scaler = new CameraScaler(this);\r\n-        GameTimer timer = new GameTimer(60); \r\n-\r\n-        renderer = new GameRenderer(this, player, map, bombManager, explosionManager, itemManager, scaler, timer, arena);\r\n-        updater = new GameUpdater(playerController, bombManager, explosionManager, itemManager, scaler, timer, arena);\r\n-\r\n-        bindToScene();\r\n-        loop.start();\r\n-    }\r\n-    \r\n-    // ... (kode bindToScene, getters tetap sama) ...\r\n-    private void bindToScene() {\r\n-        sceneProperty().addListener((obs, oldScene, newScene) -> {\r\n-            if (newScene != null) {\r\n-                widthProperty().bind(newScene.widthProperty());\r\n-                heightProperty().bind(newScene.heightProperty());\r\n-                newScene.setOnKeyPressed(e -> {\r\n-                    switch (e.getCode()) {\r\n-                        case PLUS, ADD, EQUALS -> setRenderScale(renderScale + SCALE_STEP);\r\n-                        case MINUS, SUBTRACT -> setRenderScale(renderScale - SCALE_STEP);\r\n-                        default -> {}\r\n-                    }\r\n-                });\r\n-            }\r\n-        });\r\n-    }\r\n-    public void setRenderScale(double s) { renderScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, s)); }\r\n-    public double getRenderScale() { return renderScale; }\r\n-    public double getOffsetX() { return (getWidth() - map.length * tile * renderScale) / 2.0; }\r\n-    public double getOffsetY() { return (getHeight() - map[0].length * tile * renderScale) / 2.0; }\r\n-    public int getTileSize() { return tile; }\r\n+    public double getRenderScale() { return scaler.getScale(); }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1764832503963,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-package com.myclient.render;\r\n+package com.client.render;\r\n \r\n import com.client.ClientGameState;\r\n import javafx.animation.AnimationTimer;\r\n import javafx.scene.canvas.Canvas;\r\n"
                },
                {
                    "date": 1765091651780,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,63 +1,133 @@\n package com.client.render;\r\n \r\n import com.client.ClientGameState;\r\n+import com.client.App;\r\n+import com.client.core.InputHandler;\r\n+import com.client.network.InputSender;\r\n+\r\n import javafx.animation.AnimationTimer;\r\n import javafx.scene.canvas.Canvas;\r\n import javafx.scene.input.KeyCode;\r\n+import javafx.scene.input.KeyEvent;\r\n \r\n public class GameCanvas extends Canvas {\r\n     \r\n-    // Referensi ke \"Otak Semu\" Client\r\n     private final ClientGameState gameState;\r\n     private final GameRenderer renderer;\r\n     private final CameraScaler scaler;\r\n \r\n-    // Loop Render\r\n+    // Tambahan: Input Handler + Input Sender\r\n+    private final InputHandler input = new InputHandler();\r\n+    private final InputSender sender = new InputSender(App.network);\r\n+\r\n+    // Tambahkan Game Loop Kirim Input\r\n     private final AnimationTimer loop = new AnimationTimer() {\r\n         long last = System.nanoTime();\r\n \r\n         @Override\r\n         public void handle(long now) {\r\n             double dt = (now - last) / 1e9;\r\n             last = now;\r\n             \r\n-            // 1. Update animasi visual (bukan logika game)\r\n+            // 1. Kirim input ke server\r\n+            sendInputsToServer();\r\n+\r\n+            // 2. Update animasi visual\r\n             if (gameState != null) {\r\n                 gameState.updateVisuals(dt);\r\n             }\r\n \r\n-            // 2. Render\r\n+            // 3. Render\r\n             renderer.render();\r\n         }\r\n     };\r\n \r\n     public GameCanvas(ClientGameState gameState) {\r\n         this.gameState = gameState;\r\n         this.scaler = new CameraScaler(this);\r\n-        \r\n-        // Renderer mengambil data dari gameState\r\n         this.renderer = new GameRenderer(this, gameState, scaler);\r\n \r\n-        // Bind ukuran canvas ke scene nanti\r\n+        // Bind ukuran canvas ke screen\r\n         widthProperty().addListener(evt -> renderer.render());\r\n         heightProperty().addListener(evt -> renderer.render());\r\n+\r\n+        // === REGISTER INPUT LISTENER ===\r\n+        setFocusTraversable(true);\r\n+\r\n\\ No newline at end of file\n+        setOnKeyPressed(this::onKeyDown);\r\n+        setOnKeyReleased(this::onKeyUp);\r\n     }\r\n \r\n+    private void onKeyDown(KeyEvent e) {\r\n+        input.keyDown(e);\r\n+        System.out.println(\"[KEY DOWN] \" + e.getCode());\r\n+    }\r\n+\r\n+    private void onKeyUp(KeyEvent e) {\r\n+        input.keyUp(e);\r\n+        System.out.println(\"[KEY UP] \" + e.getCode());\r\n+    }\r\n+\r\n+    // === Kirim Input Ke Server Setiap Frame ===\r\n+    private void sendInputsToServer() {\r\n+\r\n+        // UP\r\n+        if (input.isUp()) {\r\n+            sender.sendInput(\"UP\", true);\r\n+            System.out.println(\"[SEND INPUT] UP TRUE\");\r\n+        } else {\r\n+            sender.sendInput(\"UP\", false);\r\n+        }\r\n+\r\n+        // DOWN\r\n+        if (input.isDown()) {\r\n+            sender.sendInput(\"DOWN\", true);\r\n+            System.out.println(\"[SEND INPUT] DOWN TRUE\");\r\n+        } else {\r\n+            sender.sendInput(\"DOWN\", false);\r\n+        }\r\n+\r\n+        // LEFT\r\n+        if (input.isLeft()) {\r\n+            sender.sendInput(\"LEFT\", true);\r\n+            System.out.println(\"[SEND INPUT] LEFT TRUE\");\r\n+        } else {\r\n+            sender.sendInput(\"LEFT\", false);\r\n+        }\r\n+\r\n+        // RIGHT\r\n+        if (input.isRight()) {\r\n+            sender.sendInput(\"RIGHT\", true);\r\n+            System.out.println(\"[SEND INPUT] RIGHT TRUE\");\r\n+        } else {\r\n+            sender.sendInput(\"RIGHT\", false);\r\n+        }\r\n+\r\n+        // BOMB\r\n+        if (input.isPlace()) {\r\n+            sender.sendPlaceBomb();\r\n+            System.out.println(\"[SEND ACTION] PLACE_BOMB\");\r\n+        }\r\n+    }\r\n+\r\n     public void start() {\r\n+        requestFocus();  // <= PENTING AGAR KEYBOARD WORKS\r\n         loop.start();\r\n     }\r\n \r\n     public void stop() {\r\n         loop.stop();\r\n     }\r\n \r\n-    // Helper untuk Input Zoom (Optional)\r\n+    // Input Zoom (Optional)\r\n     public void handleInput(KeyCode code) {\r\n         switch (code) {\r\n             case EQUALS, ADD -> scaler.addScale(0.1);\r\n             case MINUS, SUBTRACT -> scaler.addScale(-0.1);\r\n         }\r\n     }\r\n \r\n-    public double getRenderScale() { return scaler.getScale(); }\r\n-}\n+    public double getRenderScale() { \r\n+        return scaler.getScale(); \r\n+    }\r\n+}\r\n"
                }
            ],
            "date": 1764831883073,
            "name": "Commit-0",
            "content": "package com.client.render;\r\n\r\nimport com.client.core.Arena;\r\nimport com.client.core.CollisionHandler;\r\nimport com.client.core.GameTimer;\r\nimport com.client.core.InputHandler;\r\nimport com.client.entities.Player;\r\nimport com.client.managers.BombManager;\r\nimport com.client.managers.ExplosionManager;\r\nimport com.client.managers.ItemManager; \r\nimport com.client.managers.PlayerController;\r\nimport com.client.map.MapGenerator;\r\n\r\nimport javafx.animation.AnimationTimer;\r\nimport javafx.scene.canvas.Canvas;\r\n\r\npublic class GameCanvas extends Canvas {\r\n    private final GameUpdater updater;\r\n    private final GameRenderer renderer;\r\n\r\n    private double renderScale = 1.8;\r\n    private static final double MIN_SCALE = 0.5;\r\n    private static final double MAX_SCALE = 4.0;\r\n    private static final double SCALE_STEP = 0.1;\r\n\r\n    private final int tile = 32;\r\n    private final int[][] map;\r\n    private final Arena arena;\r\n\r\n    // Loop game\r\n    private final AnimationTimer loop = new AnimationTimer() {\r\n        long last = System.nanoTime();\r\n\r\n        @Override\r\n        public void handle(long now) {\r\n            double dt = (now - last) / 1e9;\r\n            last = now;\r\n            updater.update(dt);\r\n            renderer.render();\r\n        }\r\n    };\r\n    \r\n    // Method untuk Stop Loop saat keluar room\r\n    public void stop() {\r\n        loop.stop();\r\n    }\r\n\r\n    // Method untuk Resume Game dari Pause Menu\r\n    public void resume() {\r\n        updater.resumeGame();\r\n    }\r\n\r\n    public GameCanvas(Player player, InputHandler input) {\r\n        int[] spawnPos = new int[2];\r\n        this.map = MapGenerator.generate(13, 13, spawnPos);\r\n        this.arena = new Arena(map);\r\n\r\n        ItemManager itemManager = new ItemManager(tile);\r\n        BombManager bombManager = new BombManager(this);\r\n        ExplosionManager explosionManager = new ExplosionManager(map, itemManager); \r\n        CollisionHandler collider = new CollisionHandler(map, tile);\r\n\r\n        PlayerController playerController = new PlayerController(\r\n                player, input, collider, bombManager, explosionManager, spawnPos\r\n        );\r\n\r\n        CameraScaler scaler = new CameraScaler(this);\r\n        GameTimer timer = new GameTimer(60); \r\n\r\n        renderer = new GameRenderer(this, player, map, bombManager, explosionManager, itemManager, scaler, timer, arena);\r\n        updater = new GameUpdater(playerController, bombManager, explosionManager, itemManager, scaler, timer, arena);\r\n\r\n        bindToScene();\r\n        loop.start();\r\n    }\r\n    \r\n    // ... (kode bindToScene, getters tetap sama) ...\r\n    private void bindToScene() {\r\n        sceneProperty().addListener((obs, oldScene, newScene) -> {\r\n            if (newScene != null) {\r\n                widthProperty().bind(newScene.widthProperty());\r\n                heightProperty().bind(newScene.heightProperty());\r\n                newScene.setOnKeyPressed(e -> {\r\n                    switch (e.getCode()) {\r\n                        case PLUS, ADD, EQUALS -> setRenderScale(renderScale + SCALE_STEP);\r\n                        case MINUS, SUBTRACT -> setRenderScale(renderScale - SCALE_STEP);\r\n                        default -> {}\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n    public void setRenderScale(double s) { renderScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, s)); }\r\n    public double getRenderScale() { return renderScale; }\r\n    public double getOffsetX() { return (getWidth() - map.length * tile * renderScale) / 2.0; }\r\n    public double getOffsetY() { return (getHeight() - map[0].length * tile * renderScale) / 2.0; }\r\n    public int getTileSize() { return tile; }\r\n}"
        }
    ]
}